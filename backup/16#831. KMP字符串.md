# 831. KMP字符串

https://www.acwing.com/problem/content/833/
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=1000010;
int n,m;
char p[N],s[M];
int ne[N];
int main(){
	cin>>n>>p+1>>m>>s+1;
	for(int i=2,j=0;i<=n;i++){
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1])j++;
		ne[i]=j;
	}
	for(int i=1,j=0;i<=m;i++){
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1])j++;
		if(j==n){
		cout<<i-n<<' ';
		j=ne[j];	
		}
	}

return 0;
}
```
### 解释
这段代码是使用KMP算法（Knuth-Morris-Pratt算法）来解决字符串匹配问题的C++实现。KMP算法是一种高效的字符串搜索算法，它通过预处理子串（模式串）来避免在主串（文本串）中的不必要的回溯。

下面是对代码的详细解释：

1. **变量声明和初始化**:
   - `const int N=100010, M=100010;` 定义了两个常量，分别表示模式串和文本串的最大长度。
   - `int n, m;` 定义了两个整型变量，用于存储模式串和文本串的实际长度。
   - `char p[N], s[M];` 定义了两个字符数组，`p` 用于存储模式串，`s` 用于存储文本串。
   - `int ne[N];` 定义了一个整型数组，用于存储KMP算法中的“部分匹配表”（也称为“next数组”）。

2. **输入处理**:
   - `cin>>n>>p+1>>m>>s+1;` 读取模式串和文本串的长度和内容。这里的`p+1`和`s+1`意味着从数组的第二个位置开始存储字符串，使得下标从1开始，便于后续处理。

3. **构建next数组**:
   - `for(int i=2,j=0;i<=n;i++)` 循环用于构建next数组。`i`是模式串的当前位置，`j`是最长相等前后缀的长度。
   - `while(j&&p[i]!=p[j+1]) j=ne[j];` 当`p[i]`与`p[j+1]`不匹配时，回退到之前的位置。
   - `if(p[i]==p[j+1])j++;` 如果当前字符匹配，则增加`j`的长度。
   - `ne[i]=j;` 设置next数组的当前位置的值。

4. **KMP匹配过程**:
   - `for(int i=1,j=0;i<=m;i++)` 循环用于在文本串中查找模式串。`i`是文本串的当前位置，`j`是模式串的当前匹配位置。
   - `while(j&&s[i]!=p[j+1]) j=ne[j];` 当文本串和模式串当前位置不匹配时，使用next数组回退模式串的位置。
   - `if(s[i]==p[j+1])j++;` 如果当前字符匹配，增加`j`的长度。
   - `if(j==n)` 如果完全匹配（即`j`等于模式串长度），输出匹配位置并回退`j`。

5. **输出和程序结束**:
   - `cout<<i-n+1;` 当找到一个匹配时，输出该匹配在文本串中的起始位置。
   - `j=ne[j];` 更新`j`为next数组的值，准备进行下一次匹配。
   - `return 0;` 程序正常结束。

总结，这段代码实现了KMP算法，通过预处理模式串来优化字符串匹配过程，避免了在文本串中不必要的回溯，从而提高了字符串匹配的效率。

---

* Link: https://github.com/justonehe/Algorithm/issues/16
* Labels: `模板`, `AcWing`, `KMP算法`
* Creation Date: 2023-12-29T14:33:57Z
